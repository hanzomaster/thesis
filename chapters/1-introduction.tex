\chapter{Đặt vấn đề}\label{chap1}
Kiểm thử và đảm bảo chất lượng phần mềm đã và đang đóng vai trò quan trọng trong quá trình phát triển phần mềm \cite{GiaoTrinhKiemThu}. Ngày nay, với sự phát triển mạnh mẽ của công nghệ, cuộc sống con người gắn liền với các phần mềm, các thiết bị điện tử thông minh phục vụ các nhu cầu thiết yếu trong cuộc sống. Trong đó, các dự án nhúng viết bằng C/C++ đã và đang tạo ra các sản phẩm phần mềm thông minh cần thiết cho người dùng \cite{plauger1997embedded}. Với sự phát triển của ngành công nghiệp ô tô, các dự án nhúng C/C++ đang dần xuất hiện trong các phần mềm điều khiển trên xe hơi\cite{ehman2017power}. Để đảm bảo an toàn cho người dùng khi sử dụng các sản phẩm phần mềm, chất lượng mã nguồn cần được đảm bảo một cách chính xác theo các tiêu chuẩn nghiêm ngặt như ISO (ISO-9126 \cite{ali2017iso}, ISO-26262 \cite{Hillenbrand2012_1000025616}) hay MISRA-C\footnote{https://misra.org.uk/misra-c/}. Thực tế cho thấy rằng phần lớn các dự án nhúng C/C++ có cấu trúc mã nguồn phức tạp, có nhiều sự tương tác giữa các mô-đun và có kích thước lớn. Bởi vậy, để phát hiện sớm các lỗi phát sinh, quá trình kiểm thử thường được triển khai từ sớm, ngay cả khi mã nguồn chưa đầy đủ, mới chỉ có các lớp giao diện được đề ra bởi lập trình viên. Phương pháp kiểm thử thủ công bộc lộ nhiều khó khăn, tiêu tốn nhiều thời gian và chi phí khi triển khai kiểm thử từ sớm như vậy bởi quá trình kiểm thử đi kèm việc tạo giả lập mã nguồn cho các đơn vị chưa được cài đặt. Do đó, việc kiểm thử tự động cho các dự án nhúng C/C++, ngay cả khi mã nguồn chưa đầy đủ, đã và đang trở thành thách thức lớn được không chỉ cộng đồng nghiên cứu mà còn được các công ty phát triển phần mềm quan tâm.

Kiểm thử phần mềm tự động đã và đang được áp dụng rộng rãi nhằm giảm thiểu chi phí của quá trình kiểm thử. Các kỹ thuật kiểm thử tự động dựa trên đồ thị dòng điều khiển (CFG) và đồ thị dòng dữ liệu (Data flow) là hai hướng nghiên cứu chính được nhiều nhà nghiên cứu quan tâm. Trong đó, kỹ thuật kiểm thử tự động dựa trên CFG được sử dụng phổ biến với hai hướng tiếp cận chính là kiểm thử tĩnh \cite{WARD:1989:TheStaticAnalysisofSafetyCriticalSoftwareUsingMALPAS, SecureProgrammingWithStaticAnalysis, Wichmann:1995:Industrialperspectiveonstaticanalysis, Buckle:1998:StaticAnalysisofSafetyCriticalSoftwareTechniquesToolsandExperiences} và kiểm thử động \cite{Grigorenko:1998:DynamicTesting}. Mỗi hướng tiếp cận đều có ưu, nhược điểm riêng nhưng nhìn chung đều mang lại hiệu quả cao trong việc đảm bảo chất lượng phần mềm. Cụ thể, kiểm thử tĩnh tập trung vào việc sinh dữ liệu kiểm thử dựa trên quá trình phân tích mã nguồn mà không cần chạy chương trình. Kĩ thuật kiểm thử tĩnh cung cấp nhiều lợi ích khi kĩ thuật này có thể áp dụng sớm trong vòng đời phát triển phần mềm, từ đó phát hiện sớm các lỗi phát sinh, các sai sót trong đặc tả, giúp giảm thời gian và công sức kiểm thử. Tuy nhiên, kiểm thử tĩnh có một số nhược điểm như yêu cầu nhiều tài liệu liên quan, không phát hiện được lỗi tiềm ẩn trong quá trình chạy. Do vậy, hướng tiếp cận kiểm này khó có thể tiến hành tự động hoàn toàn. Kiểm thử động là hướng tiếp cận kiểm thử dựa trên việc thực thi chương trình để phát hiện lỗi, sai sót trong cài đặt so với đặc tả. Hai hướng tiếp cận có những ưu, nhược điểm bổ trợ cho nhau nên chúng thường được áp dụng đồng thời trong quá trình kiểm thử. 


Kế thừa từ hai hướng tiếp cận trước đó, Godefroid và đồng nghiệp đã đề xuất một phương pháp kiểm thử tượng trưng động \cite{ConcolicTesting}, nhằm vượt qua nhược điểm và tận dụng những ưu điểm của kiểm thử tĩnh và kiểm thử động. Quá trình sinh dữ liệu kiểm thử trong phương pháp này bao gồm ba pha chính: (i) sinh dữ liệu kiểm thử khởi tạo, (ii) thực thi dữ liệu kiểm thử và phân tích đường thi hành, và (iii) sinh dữ liệu kiểm thử có định hướng. Phương pháp bắt đầu bằng việc sinh ngẫu nhiên dữ liệu kiểm thử khởi tạo. Sau khi thực thi dữ liệu kiểm thử ngẫu nhiên, có thể tồn tại một số câu lệnh và nhánh chưa được kiểm thử. Để giải quyết vấn đề này, kiểm thử tượng trưng động chọn một đường thi hành chưa được viếng thăm trên CFG của đơn vị kiểm thử. Điều này cho phép sinh dữ liệu kiểm thử có định hướng, nhằm phủ đường thi hành đó. Phương pháp này có khả năng đạt được độ phủ mã nguồn cao hơn so với các hướng tiếp cận truyền thống. Trong thực tế, kiểm thử tượng trưng động đã và đang được ứng dụng trong nhiều dự án công nghiệp, với mục tiêu tăng cường độ phủ mã nguồn và phát hiện lỗi chương trình với chi phí thấp. Những công cụ như DART \cite{DART}, CUTE \cite{CUTE}, PathCrawler \cite{PathCrawler}, SMART \cite{SMART}, RANDOOP \cite{FeedbackDirectedRandomTestGeneration}, SAGE \cite{SAGE}, CREST \cite{HeuristicsForScalableDynamicTestGeneration}, CAUT \cite{CAUT}, CFT4CUnit \cite{AMethodForAutomatedUnitTestingOfCPrograms} và nhiều công cụ khác đã chọn cách sinh ngẫu nhiên dữ liệu khởi tạo trong một phạm vi cụ thể. Hơn nữa, một số phương pháp khác như KLEE \cite{KLEE}, EXE \cite{EXE}, SAVIOR \cite{SAVIOR}, thay vì thực thi chương trình với dữ liệu đầu vào được sinh thủ công hoặc ngẫu nhiên, đã áp dụng kiểm thử tượng trưng động để sinh dữ liệu đầu vào có giá trị tượng trưng có thể gây lỗi chương trình. Điều này thể hiện rằng kiểm thử tượng trưng động đang thu hút sự quan tâm lớn từ cả cộng đồng nghiên cứu và các doanh nghiệp phát triển phần mềm.

Hiện nay, dù đã có nhiều nghiên cứu xoay quanh kiểm thử tượng trưng động cho mã nguồn C/C++ nhưng vẫn tồn tại một số hạn chế khi áp dụng phương pháp trong quá trình kiểm thử đơn vị. Trong đó, một số hạn chế bắt nguồn từ việc mã nguồn kiểm thử chưa đầy đủ. Mã nguồn trong giai đoạn cài đặt của vòng đời phát triển thường bắt đầu với việc lập trình viên thiết kế, đặc tả và cài đặt các lớp giao diện, kiểu dữ liệu trừu tượng, v.v. Mục đích của việc này là để các thành viên trong đội nhóm phát triển biết được các thành phần trong mã nguồn cung cấp các dịch vụ gì, qua đó đẩy nhanh tốc độ cài đặt thành phần được giao. Điều này dẫn tới hạn chế đầu tiên đó là mã nguồn có thể chứa hàm thiếu định nghĩa. Hàm thiếu định nghĩa là những hàm mà có nguyên mẫu được khai báo, nhưng không có định nghĩa hàm. Điều này có thể xuất hiện khi nhóm phân chia công việc và mỗi thành viên chịu trách nhiệm về việc triển khai một số hàm cụ thể. Tuy nhiên, việc quản lý và theo dõi những hàm này trong quá trình phát triển và kiểm thử có thể gây khó khăn, đặc biệt khi số lượng hàm thiếu định nghĩa lớn. Bài toán trở nên phức tạp hơn khi áp dụng kiểm thử tự động bởi các công cụ kiểm thử tự động thường đòi hỏi mã nguồn đầy đủ để có thể thực thi được các ca kiểm thử. Chương trình chứa các hàm thiếu định nghĩa có thể biên dịch được nhưng không thể liên kết các tệp đối tượng để tạo thành một tệp thực thi. Theo nghiên cứu của khóa luận, hiện nay chưa có phương pháp tự động nào giúp xử lý các hàm thiếu định nghĩa. Điều này khiến quá trình kiểm thử mất nhiều thời gian và công sức hơn. Hạn chế tiếp theo đó là sự phụ thuộc vào các hàm, thành phần khác trong mã nguồn khiến quá trình thực hiện kiểm thử tốn nhiều thời gian song kết quả độ phủ chưa cao. Ở mức độ kiểm thử đơn vị, quá trình kiểm thử nên tập trung vào đơn vị chính mà không cần quan tâm đến các phụ thuộc. Năm 2022, Nguyên Hương và các cộng sự của mình đã giới thiệu phương pháp sinh stub tự động AS4UT \cite{TUNG2022106821} nhằm giải quyết vấn đề trên. Tuy nhiên, phương pháp vẫn còn nhiều hạn chế khi chưa giải quyết được lời gọi phương thức. C++ là ngôn ngữ hướng đối tượng nên lời gọi phương thức đóng vai trò cầu nối cung cấp dịch vụ của một đối tượng. Các lời gọi như vậy có thể thay đổi giá trị thuộc tính của đối tượng gọi. Sự thay đổi này có thể dẫn đến những điều kiện trong đơn vị kiểm thử không thể thỏa mãn được nếu chỉ đơn thuần áp dụng phương pháp AS4UT. Bài toán trở nên phức tạp hơn khi phương thức được gọi có thể là hàm thiếu định nghĩa. Do đó, cần thiết phải nghiên cứu và phát triển giải pháp kiểm thử đơn vị tự động hiệu quả cho mã nguồn C/C++ chứa hàm thiếu định nghĩa. 

Để xử lý các hạn chế trên, khóa luận đề xuất một phương pháp nhằm tự động phát hiện và xử lý các hàm thiếu định nghĩa, đồng thời sinh giả lập mã nguồn (gọi tắt là stub) tự động cho các lời gọi hàm trong quá trình kiểm thử đơn vị. Ý tưởng chính của phương pháp là cải tiến phương pháp kiểm thử đơn vị tự động truyền thống với việc bổ sung quá trình xử lý hàm thiếu định nghĩa sau quá trình phân tích mã nguồn, và bổ sung phương pháp xử lý lời gọi phương thức trong quá trình xử lý lời gọi hàm khi sinh stub tự động. Trong đó, quá trình xử lý hàm thiếu định nghĩa sẽ xác định danh sách các nguyên mẫu hàm thiếu định nghĩa cần quan tâm rồi sinh thân hàm giả cho chúng. Quy trình xử lý nguyên mẫu hàm được tách thành hai quy trình con gồm xử lý nguyên mẫu hàm ảo và nguyên mẫu hàm bình thường (gọi tắt là nguyên mẫu hàm). Sau đó, phương pháp đồng thời áp dụng kỹ thuật kiểm thử tượng trưng động và phương pháp sinh stub tự động để sinh dữ liệu kiểm thử tự động cho các đơn vị được kiểm thử. Điều này cho phép phương pháp đề xuất rút ngắn được thời gian chuẩn bị môi trường kiểm thử và đồng thời đạt được độ phủ mã nguồn cao hơn khi kiểm thử các dự án chứa mã nguồn thiếu định nghĩa. Qua đó cho thấy khả năng ứng dụng thực tiễn của phương pháp đề xuất trong các dự án thực tế để giảm thiểu chi phí kiểm thử và nâng cao chất lượng chương trình.

Phần còn lại của khóa luận được trình bày như sau. Chương~\ref{chap2} trình bày một số kiến thức cơ sở liên quan đến chủ để sinh dữ liệu kiểm thử tự động cho các dự án C/C++, tự động giả lập mã nguồn và làm rõ khái niệm hàm thiếu định nghĩa. Tiếp theo, Chương~\ref{chap3} chia sẻ chi tiết về phương pháp kiểm thử đơn vị tự động cho mã nguồn C/C++ chứa hàm thiếu định nghĩa. Chương~\ref{chap4} mô tả công cụ thực nghiệm và một số kết quả thực nghiệm đánh giá tính hiệu quả của phương pháp đề xuất. Cuối cùng, một số kết luận về phương pháp đề xuất được thảo luận ở Chương~\ref{chap5}. 